# テックブログ記事レビュー スタイルガイド

## 1. はじめに

このドキュメントは、Gemini Code Assistantがテックブログの記事をレビューする際のスタイルガイドです。
質の高い記事を作成し、読者に正確で分かりやすい情報を提供することを目的とします。

### 1.1. レビューの優先度

各チェック項目には以下の優先度が設定されています:

- **MUST**: 必ず修正すべき重大な問題（技術的誤り、誤解を招く表現など）
- **SHOULD**: 記事の質を大きく向上させる推奨事項（構成の改善、説明の追加など）
- **MAY**: あれば望ましい改善提案（表現の洗練、図表の追加など）

### 1.2. レビューコメントの書き方

- **具体的に**: 「わかりにくい」ではなく「この段落では主語が不明確です」
- **建設的に**: 問題点と改善案をセットで提示
- **肯定的に**: 良い点も積極的に評価
- **簡潔に**: 1コメント1ポイントを原則とする

## 2. レビューの観点

レビューを行う際は、以下の点に重点を置いて確認します。

### 2.1. 技術的な正確さ (優先度: MUST)

**チェック項目（プログラミング系記事）:**

- [ ] 技術、ライブラリ、フレームワークの情報は正確か
- [ ] バージョン情報が明記されているか（重要な場合）
- [ ] 事実に基づかない、誤解を招く表現はないか
- [ ] コードサンプルは文法的に正しく、実行可能か
- [ ] 外部リソース（公式ドキュメント、記事など）への参照は正確か
- [ ] 非推奨のAPIや古い情報を使っていないか

**チェック項目（論文解説記事）:**

- [ ] 論文の基本情報（著者、タイトル、学会/ジャーナル、年度）が正確に記載されているか
- [ ] 論文のDOIやarXiv IDが記載されているか
- [ ] 論文の主張や結論を正確に理解し、解釈しているか
- [ ] 数式の転記に誤りがないか
- [ ] 実験結果やベンチマークデータの引用が正確か
- [ ] 論文の図表を使用する場合、適切に引用されているか
- [ ] 自分の解釈と論文の記述を明確に区別しているか

**良い例（プログラミング系）:**

```markdown
## Node.jsでのファイル読み込み

Node.js v18以降では、`fs/promises`を使った非同期処理が推奨されています。

\```javascript
import { readFile } from 'fs/promises';

const data = await readFile('./example.txt', 'utf-8');
console.log(data);
\```

> 参考: [Node.js File system API](https://nodejs.org/docs/latest-v18.x/api/fs.html)
```

**良い例（論文解説）:**

```markdown
## Attention Is All You Need の提案手法

本論文では、Transformerアーキテクチャが提案されました。

> Vaswani, A., et al. (2017). "Attention is All You Need". 
> In Advances in Neural Information Processing Systems 30 (NeurIPS 2017).
> [arXiv:1706.03762](https://arxiv.org/abs/1706.03762)

論文では、Self-Attentionの計算式を以下のように定義しています:

$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$

ここで、$Q$はQuery、$K$はKey、$V$はValueを表します（論文のSection 3.2.1より）。
```

**悪い例:**

```markdown
// バージョン情報なし、動作しないコード
Node.jsでファイルを読むにはこうします。

\```javascript
const data = readFile('./example.txt');  // エラー: readFileは未定義
\```

// 論文解説で出典が不明確
Transformerでは注意機構を使います。数式はこんな感じです。
// 論文情報なし、数式の出典なし
```

**レビューコメント例:**

- ✅ 「バージョンv18と明記されており、読者が環境を理解しやすいです」
- ✅ 「論文の基本情報とarXiv IDが明記され、数式の出典セクションも示されており正確です」
- ❌ 「`readFile`の使用にはimport文が必要です。また、awaitキーワードがないと正しく動作しません」
- ❌ 「この数式は論文のどのセクションから引用したか明記してください」

### 2.2. 明確性と論理性 (優先度: SHOULD)

**チェック項目:**

- [ ] 記事の目的や主張が冒頭で明確に述べられているか
- [ ] 文章の構成は論理的で、話の流れは自然か
- [ ] 各セクション間の接続がスムーズか
- [ ] 専門用語や略語には、初出時に説明や注釈があるか
- [ ] 結論や要点が明確にまとめられているか
- [ ] 前提条件や対象読者が明示されているか

**良い例:**

```markdown
## はじめに

この記事では、DDD（ドメイン駆動設計）における値オブジェクトの実装パターンを、
Go言語を使って解説します。DDDの基本概念を理解している中級者向けの内容です。

### 前提環境
- Go 1.21以降
- DDDの基本概念（エンティティ、値オブジェクト）の理解
```

**悪い例:**

```markdown
今回は値オブジェクトについて書きます。コードはこんな感じです。
// 何を目的とした記事か、誰向けかが不明確
```

**レビューコメント例:**

- ✅ 「冒頭で記事の目的と対象読者が明確に示されており、読者が読み進めるべきか判断できます」
- ❌ 「DDDの略語が初出時に説明されていません。初めて見る読者のために『DDD（Domain-Driven Design、ドメイン駆動設計）』のように注釈を入れましょう」

### 2.3. 読みやすさ (優先度: SHOULD)

**チェック項目:**

- [ ] 全体として、読者がストレスなく読み進められる構成か
- [ ] 一文が長すぎないか（目安: 60-80文字以内）
- [ ] 冗長な表現や重複がないか
- [ ] 箇条書きや図表が効果的に使われているか
- [ ] コードブロックには適切な言語指定があるか
- [ ] 段落の長さは適切か（目安: 3-5文程度）
- [ ] 見出しの階層構造（h2, h3, h4）は適切か

**良い例:**

```markdown
## エラーハンドリングの3つのポイント

エラー処理を適切に行うには、以下の点に注意します:

1. **エラーの種類を明確にする**: 復旧可能か不可能かを区別
2. **コンテキスト情報を付与する**: エラー発生時の状況を記録
3. **適切なレベルでキャッチする**: 処理できる場所で捕捉

それぞれ詳しく見ていきましょう。
```

**悪い例:**

```markdown
エラー処理はとても重要で、エラーが発生した時にどうするかを考える必要があって、
エラーにはいろいろな種類があって復旧できるものとできないものがあるので、
それを区別して処理することが大切です。
// 一文が長すぎて読みにくい
```

**レビューコメント例:**

- ✅ 「箇条書きを使って3つのポイントが明確に整理されており、読みやすいです」
- ❌ 「この文は80文字を超えています。2つの文に分割するとより読みやすくなります」

### 2.4. 実用性 (優先度: SHOULD)

**チェック項目（プログラミング系記事）:**

- [ ] 読者が実際の業務や学習に活かせる内容か
- [ ] 再現可能な手順や具体的な情報が提供されているか
- [ ] 環境構築の手順や依存関係が明示されているか
- [ ] 発生しうる問題とその対処法が示されているか
- [ ] 記事を読んだ後に読者が得られるものが明確か
- [ ] サンプルコードは完全で、そのまま動作するか

**チェック項目（論文解説記事）:**

- [ ] 論文の内容を読者が理解できるように十分に解説されているか
- [ ] 難解な概念を分かりやすく説明しているか
- [ ] 実装への応用方法や実用例が示されているか（可能な場合）
- [ ] 論文の限界や課題についても言及しているか
- [ ] 関連研究との位置づけが説明されているか
- [ ] 読者が元論文を読む際の理解の助けになるか

**良い例（プログラミング系）:**

```markdown
## 環境構築

以下のコマンドで必要なパッケージをインストールします:

\```bash
npm install --save-dev typescript @types/node
\```

### トラブルシューティング

**エラー: `Cannot find module 'typescript'`**

解決策: `node_modules`を削除して再インストールします。

\```bash
rm -rf node_modules package-lock.json
npm install
\```
```

**良い例（論文解説）:**

```markdown
## Self-Attentionの仕組み

論文では複雑な数式で表現されていますが、直感的には以下のように理解できます:

1. **Query**: 「何を探したいか」を表すベクトル
2. **Key**: 「何を持っているか」を表すベクトル
3. **Value**: 「実際の情報」を表すベクトル

これは、図書館で本を探す際に、検索クエリ(Query)と本のタイトル(Key)を照合し、
該当する本の内容(Value)を取得するプロセスに似ています。

### 実装への応用

PyTorchでは、`nn.MultiheadAttention`として実装されており、以下のように使用できます:

\```python
import torch.nn as nn

attention = nn.MultiheadAttention(embed_dim=512, num_heads=8)
\```
```

**悪い例:**

```markdown
環境を整えたら、コードを書いて実行しました。動きました。
// 具体的な手順がなく、読者が再現できない

// 論文解説で説明が不足
論文では新しい手法を提案しています。数式は複雑なので省略します。
// 読者の理解を助ける説明がない
```

**レビューコメント例:**

- ✅ 「トラブルシューティングのセクションで想定される問題と解決策が示されており、実用的です」
- ✅ 「Self-Attentionの仕組みを図書館の例えで説明しており、初学者にも理解しやすいです」
- ❌ 「環境構築の手順が不足しています。必要なパッケージとそのインストール方法を追加してください」
- ❌ 「数式の意味を省略せず、読者が理解できるように各変数の意味を説明してください」

### 2.5. 独自性 (優先度: SHOULD)

**チェック項目:**

- [ ] 筆者自身の経験、考察、意見が含まれているか
- [ ] 他の類似記事にはない独自の視点や付加価値があるか
- [ ] 公式ドキュメントの翻訳や単なる情報の羅列になっていないか
- [ ] 実際に試した結果や気づきが共有されているか
- [ ] 「なぜそうするのか」の理由や背景が説明されているか

**良い例:**

```markdown
## なぜECSよりもFargateを選んだのか

検討の結果、以下の理由からFargateを採用しました:

1. **運用コストの削減**: EC2インスタンスの管理が不要
2. **小規模チームでの運用**: 3人のチームではインフラ管理の負担が大きすぎた
3. **コスト面**: 我々のワークロード（1日数回のバッチ処理）では、
   Fargateの従量課金のほうが約30%安価だった

実際に運用して3ヶ月が経ちましたが、インフラトラブルはゼロで、
開発に集中できる環境が整いました。
```

**悪い例:**

```markdown
Fargateは便利なサービスです。公式ドキュメントによると...（以下、公式の引用のみ）
// 独自の経験や考察がない
```

**レビューコメント例:**

- ✅ 「実際の運用経験から得た知見と具体的な数値が示されており、読者にとって価値のある情報です」
- ❌ 「公式ドキュメントの情報が中心です。実際に使ってみた感想や、選定時の判断基準を追加すると独自性が高まります」

### 2.6. コードの品質 (優先度: MUST)

**チェック項目（プログラミング系記事）:**

- [ ] コードサンプルは読みやすく、一貫したスタイルでフォーマットされているか
- [ ] 変数名や関数名は役割が分かりやすいように命名されているか
- [ ] 適切なコメントが付いているか（複雑なロジックには説明を追加）
- [ ] ベストプラクティスや一般的な設計原則に沿っているか
- [ ] セキュリティ上の問題がないか（ハードコードされたパスワードなど）
- [ ] エラーハンドリングが適切か
- [ ] コードブロックに言語指定（\`\`\`python、\`\`\`javascript など）があるか

**チェック項目（論文解説記事）:**

- [ ] 数式は正確に記述されているか（LaTeX/KaTeX形式で）
- [ ] 数式の各記号の意味が説明されているか
- [ ] アルゴリズムの擬似コードは読みやすいか
- [ ] 論文の図表を引用する場合、十分な解像度で見やすいか
- [ ] 自作の図表は論文の内容を正確に表現しているか
- [ ] コードで実装例を示す場合、論文の定義に忠実か

**良い例:**

```markdown
\```python
from typing import List

def calculate_total_price(items: List[dict], tax_rate: float = 0.1) -> float:
    """
    商品リストから税込み合計金額を計算する

    Args:
        items: 商品情報のリスト（各要素は'price'キーを持つ辞書）
        tax_rate: 税率（デフォルト: 0.1 = 10%）

    Returns:
        税込み合計金額
    """
    subtotal = sum(item['price'] for item in items)
    return subtotal * (1 + tax_rate)
\```
```

**良い例（論文解説）:**

```markdown
## Softmax関数の定義

論文では、Softmax関数を以下のように定義しています（Equation 1）:

$$
\text{softmax}(x_i) = \frac{e^{x_i}}{\sum_{j=1}^{n} e^{x_j}}
$$

ここで:
- $x_i$: 入力ベクトルの$i$番目の要素
- $n$: ベクトルの次元数
- 出力は各要素が0〜1の範囲で、総和が1となる確率分布

### 実装例

\```python
import numpy as np

def softmax(x: np.ndarray) -> np.ndarray:
    """
    Softmax関数の実装（論文 Equation 1に対応）
    
    Args:
        x: 入力ベクトル (shape: (n,))
    
    Returns:
        確率分布 (shape: (n,))
    """
    # 数値安定性のため最大値を引く
    exp_x = np.exp(x - np.max(x))
    return exp_x / np.sum(exp_x)
\```
```

**悪い例:**

```markdown
\```
def calc(x):
    return x * 1.1  # 何を計算しているのか不明確、型ヒントなし、言語指定なし
\```

// 論文解説で数式の説明不足
$$f(x) = \frac{a}{b}$$
// 各記号の意味が不明
```

**レビューコメント例:**

- ✅ 「関数名と変数名が明確で、型ヒントとdocstringが適切に記載されています」
- ✅ 「数式の各記号の意味が明確に説明されており、実装例も論文の定義に忠実です」
- ❌ 「関数名`calc`が抽象的すぎます。`calculate_total_price`のように具体的な名前にしましょう。また、引数の型ヒントを追加してください」
- ❌ 「数式の各記号（$a$、$b$）の意味を説明してください。また、論文のどの式か（Equation番号）も明記しましょう」

### 2.7. タイトルと見出し (優先度: SHOULD)

**チェック項目:**

- [ ] タイトルは記事の内容を的確に表しているか
- [ ] タイトルは読者の興味を引くものになっているか
- [ ] 見出しの階層構造（h1→h2→h3）が適切か
- [ ] 見出しだけ読んでも記事の流れが理解できるか
- [ ] 各見出しはそのセクションの内容を要約しているか
- [ ] 見出しが長すぎないか（目安: 30文字以内）

**良い例:**

```markdown
# Go言語でのDDD実装: 値オブジェクトパターン完全ガイド

## 値オブジェクトとは
### 値オブジェクトの3つの特徴
### エンティティとの違い

## 実装パターン
### パターン1: 構造体による実装
### パターン2: 型エイリアスによる実装

## まとめ
```

**悪い例:**

```markdown
# Go

## について
### いろいろ
// 抽象的すぎて内容が不明
```

**レビューコメント例:**

- ✅ 「見出しが階層的に整理されており、目次を見るだけで記事の構成が把握できます」
- ❌ 「タイトルが抽象的です。『Go言語での○○の実装方法』のように、具体的な技術と内容を含めましょう」

### 2.8. 誤字脱字と文法 (優先度: MUST)

**チェック項目:**

- [ ] 誤字脱字がないか
- [ ] 文法的に正しい日本語表現になっているか
- [ ] 「ら抜き言葉」などの口語表現が混在していないか
- [ ] 敬体（です・ます調）と常体（だ・である調）が混在していないか
- [ ] 同じ語尾の連続（「〜ます。〜ます。〜ます。」）がないか
- [ ] 不自然な助詞の使い方がないか

**良い例:**

```markdown
この手法を使うことで、コードの保守性が向上します。
また、テストの記述も容易になります。
結果として、開発効率が大幅に改善されるでしょう。
```

**悪い例:**

```markdown
この手法を使うことで、コードの保守性が向上します。
また、テストの記述も容易になります。
結果として、開発効率が大幅に改善されます。
// 「〜ます」の連続で単調
```

**レビューコメント例:**

- ✅ 「文体が統一されており、読みやすい文章です」
- ❌ 「『見れる』は『見られる』が正しい表現です」
- ❌ 「同じ語尾が3回連続しています。『〜でしょう』『〜できます』など変化をつけましょう」

## 3. 記事の種類別ガイドライン

記事の種類によって、重点的にチェックすべきポイントが異なります。

### 3.1. チュートリアル記事

**重点チェック項目:**

- 手順が順序立てて説明されているか
- 各ステップでの期待される結果が示されているか
- 初心者でも理解できる丁寧な説明があるか
- スクリーンショットや図が適切に配置されているか

### 3.2. 技術解説記事

**重点チェック項目:**

- 技術的な背景や歴史が説明されているか
- なぜその技術が必要なのかが明確か
- 他の選択肢との比較があるか
- 実用例や応用例が示されているか

### 3.3. トラブルシューティング記事

**重点チェック項目:**

- 問題の症状が明確に記載されているか
- 原因の分析プロセスが説明されているか
- 解決策が具体的で再現可能か
- 予防策や代替案が示されているか

### 3.4. ベストプラクティス記事

**重点チェック項目:**

- 推奨する理由が論理的に説明されているか
- アンチパターンとの比較があるか
- 実際のコード例が示されているか
- 適用する際の注意点が記載されているか

### 3.5. 論文解説記事

論文解説記事では、単なる要約に留まらず、読者が論文の核心を理解し、その重要性を把握できるような付加価値を提供することが重要です。そのため、以下の点を重点的にチェックします。

**重点チェック項目:**

- [ ] **論文の基本情報**: 著者、タイトル、学会/ジャーナル、年度、DOI/arXiv IDが明記されているか
- [ ] **研究の背景と動機**: なぜこの研究が行われたのかが説明されているか
- [ ] **関連研究**: 先行研究や比較対象となる手法が紹介されているか
- [ ] **提案手法の説明**: 論文の核となる手法が分かりやすく解説されているか
- [ ] **数式の説明**: 重要な数式とその意味が丁寧に説明されているか
- [ ] **実験結果の解釈**: 結果の数値だけでなく、その意味や示唆が説明されているか
- [ ] **新規性と貢献**: 論文の新しい点や学術的貢献が明確にされているか
- [ ] **限界と今後の課題**: 論文の限界や未解決の問題についても言及されているか
- [ ] **実装への応用**: 可能であれば、実装例やコードが提供されているか
- [ ] **図表の活用**: 論文の図やアーキテクチャ図が適切に引用・説明されているか

**良い例:**

```markdown
# [論文解説] Attention Is All You Need - Transformerアーキテクチャの提案

## 論文情報

- **タイトル**: Attention Is All You Need
- **著者**: Ashish Vaswani, Noam Shazeer, et al.
- **発表**: NeurIPS 2017
- **リンク**: [arXiv:1706.03762](https://arxiv.org/abs/1706.03762)

## 研究の背景

それまでの系列変換モデル（Seq2Seq）は、RNNやLSTMに基づいていました。
しかし、以下の課題がありました:

1. 系列を順次処理するため並列化が困難
2. 長距離依存関係の学習が難しい
3. 学習時間が長い

## 提案手法: Transformer

本論文では、Recurrenceを完全に排除し、Attentionのみで構成された
Transformerアーキテクチャを提案しています。

### Self-Attentionの仕組み

Attentionの計算は以下の式で表されます（論文 Equation 1）:

$$
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
$$

- $Q$ (Query): 「何を探したいか」を表す行列
- $K$ (Key): 「何を持っているか」を表す行列
- $V$ (Value): 「実際の情報」を表す行列
- $d_k$: Keyの次元数（スケーリング係数として使用）

$\sqrt{d_k}$ で割るのは、内積の値が大きくなりすぎてsoftmaxの勾配が
消失するのを防ぐためです（論文 Section 3.2.1参照）。

## 実験結果

WMT 2014 英独翻訳タスクにおいて、以下の結果を達成:

| モデル | BLEU | 学習時間 |
|--------|------|----------|
| 既存SOTA | 26.4 | 3.5日 |
| Transformer (base) | 27.3 | 12時間 |
| Transformer (big) | **28.4** | 3.5日 |

**考察**: 同等の学習時間で大幅に性能向上し、さらに学習時間も
1/7に短縮できることが示されました。

## 新規性と貢献

1. RNNを使わずAttentionのみで高精度を達成
2. 並列化可能な構造により学習時間を大幅短縮
3. 様々なタスクに適用可能な汎用アーキテクチャ

## 限界と今後の課題

- 入力系列長が長い場合、計算量が$O(n^2)$で増加
- 小規模データでの性能は未検証
- 解釈性の問題（どの部分に注目しているかは分かるが、なぜかは不明）

## 実装例

PyTorchでの簡易実装:

\```python
import torch
import torch.nn as nn

class MultiHeadAttention(nn.Module):
    def __init__(self, d_model: int, num_heads: int):
        super().__init__()
        self.d_model = d_model
        self.num_heads = num_heads
        self.d_k = d_model // num_heads
        
        # Q, K, V の線形変換
        self.W_q = nn.Linear(d_model, d_model)
        self.W_k = nn.Linear(d_model, d_model)
        self.W_v = nn.Linear(d_model, d_model)
        self.W_o = nn.Linear(d_model, d_model)
    
    def forward(self, q, k, v):
        # Multi-head Attentionの実装（論文 Section 3.2.2）
        batch_size = q.size(0)
        
        # 線形変換とヘッド分割
        Q = self.W_q(q).view(batch_size, -1, self.num_heads, self.d_k)
        K = self.W_k(k).view(batch_size, -1, self.num_heads, self.d_k)
        V = self.W_v(v).view(batch_size, -1, self.num_heads, self.d_k)
        
        # Scaled Dot-Product Attention（Equation 1）
        scores = torch.matmul(Q, K.transpose(-2, -1)) / math.sqrt(self.d_k)
        attention = torch.softmax(scores, dim=-1)
        output = torch.matmul(attention, V)
        
        # ヘッドの結合と出力変換
        output = output.view(batch_size, -1, self.d_model)
        return self.W_o(output)
\```

## まとめ

本論文は、Attentionメカニズムのみで構成された革新的なアーキテクチャを提案し、
自然言語処理における新たな標準を確立しました。BERT、GPTなど、
その後の多くの重要なモデルの基礎となっています。
```

**悪い例:**

```markdown
# Transformerについて

Transformerという論文がありました。Attentionを使っています。
性能が良いです。以下、論文の図を貼ります。

// 論文情報なし、数式の説明なし、独自の解説なし
```

**レビューコメント例:**

- ✅ 「論文の基本情報、背景、提案手法、実験結果が体系的に整理され、実装例も含まれており非常に分かりやすいです」
- ✅ 「数式の各記号の意味と、なぜその設計になっているか（$\sqrt{d_k}$の役割など）まで説明されており、深い理解を助けます」
- ❌ 「論文の基本情報（著者、学会、年度）が不足しています。読者が原論文を参照できるよう追加してください」
- ❌ 「実験結果の数値が示されていますが、その意味や示唆の説明がありません。結果から何が言えるのか考察を追加してください」

## 4. 引用とクレジット (優先度: MUST)

**チェック項目:**

- [ ] 外部の情報源を使用する場合、適切に引用されているか
- [ ] 引用元のURLや書籍名が明記されているか
- [ ] 画像や図表の出典が示されているか
- [ ] ライセンス表記が必要な場合、適切に記載されているか
- [ ] 他者のコードを使用する場合、その旨が明記されているか

**良い例:**

```markdown
> この設計パターンは、Martin Fowlerの『Patterns of Enterprise Application Architecture』
> で紹介されているRepository Patternを参考にしています。

参考文献:
- [Go by Example: Context](https://gobyexample.com/context)
- Fowler, M. (2002). *Patterns of Enterprise Application Architecture*. Addison-Wesley.
```

**レビューコメント例:**

- ✅ 「参考文献が適切に記載されており、読者がさらに学習を深められます」
- ❌ 「この図は出典が不明です。自作の場合はその旨を、引用の場合は出典を明記してください」

## 5. レビュー対象外の項目

以下の項目はレビューの対象外とします:

- **個人的なスタイルの選択**: 技術的に正しければ、筆者の好みを尊重
- **主観的な好み**: 「この技術が好き」「このフレームワークを使いたい」といった個人の嗜好
- **記事のテーマ選定**: 筆者が書きたいテーマを自由に選ぶ権利を尊重

## 6. フィードバックの方針

### 6.1. 基本原則

- **具体的に**: 「わかりにくい」ではなく、どこがどう分かりにくいのかを明示
- **建設的に**: 問題点と改善案をセットで提示
- **肯定的に**: 良かった点も積極的に評価し、執筆者のモチベーションを高める
- **簡潔に**: 1コメント1ポイントを原則とする

### 6.2. コメントの構造

レビューコメントは以下の構造で記載します:

```markdown
## レビュー結果

### 良かった点 ✅

- [具体的な良かった箇所と理由]
- [具体的な良かった箇所と理由]

### 改善提案 (MUST) 🔴

- **[セクション名]**: [問題点]
  - 改善案: [具体的な修正案]

### 改善提案 (SHOULD) 🟡

- **[セクション名]**: [問題点]
  - 改善案: [具体的な修正案]

### 改善提案 (MAY) 🔵

- **[セクション名]**: [問題点]
  - 改善案: [具体的な修正案]
```

### 6.3. コメント例

**良い例:**

```markdown
### 改善提案 (MUST) 🔴

- **セクション2.3のコードサンプル**: `readFile`関数がimportされていません。
  - 改善案: 冒頭に`import { readFile } from 'fs/promises';`を追加してください。
```

**悪い例:**

```markdown
コードが動きません。
// 何が問題で、どう修正すべきかが不明確
```

### 6.4. トーンとマナー

- 敬語を使用し、丁寧な表現を心がける
- 批判的な表現は避け、「〜してください」ではなく「〜すると良いでしょう」
- 筆者の努力や工夫を認める言葉を添える

## 7. レビュープロセス

### 7.1. レビューの流れ

1. **全体の把握**: まず記事全体を通読し、目的とターゲット読者を理解
2. **優先度の高い項目から**: MUST項目（技術的正確さ、コード品質など）を優先的にチェック
3. **セクションごとにレビュー**: 各セクションを順番にチェック
4. **総評の作成**: 記事全体の印象と主要な改善点をまとめる

### 7.2. レビュー完了後のチェックリスト

- [ ] MUST項目はすべて確認したか
- [ ] 良かった点を少なくとも3つ挙げたか
- [ ] すべての指摘に改善案を添えたか
- [ ] レビューコメントの口調は丁寧で建設的か
- [ ] 優先度（MUST/SHOULD/MAY）を適切に設定したか
- [ ] 記事の種類（プログラミング系/論文解説）に応じた適切なチェック項目を使用したか

## 8. まとめ

このスタイルガイドは、質の高いテックブログ記事を作成するための指針です。

**対象記事の種類:**

- プログラミング技術記事（チュートリアル、技術解説、トラブルシューティング、ベストプラクティス）
- 論文解説記事（機械学習、コンピュータサイエンスなど）

**基本方針:**

すべての項目を完璧に満たす必要はありませんが、読者にとって価値のある、
正確で分かりやすい記事を目指しましょう。特に以下の点を重視します:

- **正確性**: 技術情報や論文の内容を正確に伝える（MUST）
- **分かりやすさ**: 読者が理解しやすい構成と表現を心がける（SHOULD）
- **実用性**: 読者が実際に活用できる情報を提供する（SHOULD）
- **独自性**: 筆者ならではの経験や考察を含める（SHOULD）

レビューを通じて、執筆者と読者の両方にとってより良い記事が生まれることを期待します。
