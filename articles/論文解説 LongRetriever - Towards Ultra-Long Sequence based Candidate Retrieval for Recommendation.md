---
title: "【論文解説】ByteDanceの最新検索モデル: LongRetriever - 長期間履歴をRetrievalに組み込む" # zenn: 記事のタイトル
emoji: "🛒" # zenn: アイキャッチとして使われる絵文字（1文字だけ）
type: "tech" # zenn: tech: 技術記事 / idea: アイデア記事
topics: [] # zenn: タグ。["markdown", "rust", "aws"]のように指定する
published: false # zenn: 公開設定（falseにすると下書き）
論文URL: https://arxiv.org/abs/2508.15486 # paper: URL
主な著者: Qin Ren, Zheng Chai, Xijun Xiao, et al. # paper: 主な著者
主な所属機関: ByteDance # paper: 主な所属機関
論文公開日付: 2025-08-25 # paper: 論文公開日付
tags: ["recommendation", "retrieval", "candidate generation", "sequential recommendation", "long sequence", "bytedance"] # paper: tags
---

タイトル: 【論文解説】ByteDanceの最新検索モデル: LongRetriever - 長期間履歴をRetrievalに組み込む

この記事では、ByteDanceの最新論文: [LongRetriever - Towards Ultra-Long Sequence based Candidate Retrieval for Recommendation](https://arxiv.org/abs/2508.15486)を解説します。

この論文は、推薦システムの検索（Retrieval / Candidate Generation）フェーズにおいて、これまで計算コストの制約から困難とされていた超長期間のユーザー行動履歴（Ultra-Long Sequence）と候補商品に応じた適切なユーザーベクトル表現の実用化に成功したものです。

https://arxiv.org/abs/2508.15486

※ 本記事の画像は、論文中の図表を引用しています。

本記事は、arXiv Advent Calendar 2025の12/09の記事になります。

https://qiita.com/advent-calendar/2025/arxiv

## この論文のすごいところ

この研究の特筆すべき点は、以下の3点に集約されます。

1. **検索段階での長期間履歴と候補商品に応じた適切なユーザーベクトル表現の活用**:
  計算コストが制約となる検索フェーズにおいて、これまで困難であったユーザーの全行動履歴の活用を可能にするアーキテクチャを提案しました。これにより、候補商品（コンテキスト）に応じた動的なユーザーベクトル生成を検索段階で実現しています。
2. **In-Context Trainingによる学習と推論の一貫性**:  
  履歴ベースの検索モデルで課題となる学習時のデータリーク（ターゲット情報の漏洩）を防ぎつつ、推論時と整合性の取れた学習を行うIn-Context TrainingおよびMulti-Context Retrievalを導入しました。
3. **大規模商用環境での実証**:  
  ByteDanceの大規模Eコマースプラットフォーム（数億ユーザー規模）でのA/Bテストにおいて、主要なビジネス指標（CVRやCTR）の有意な向上を達成し、既にこの手法が実際のプラットフォームに展開されています。

## なぜこの論文を選んだか


私がこの論文を選んだ理由は、主に以下の3点に強く惹かれたからです。

1. **ByteDanceでの実用実績と大規模デプロイ**: 
  理論的な提案にとどまらず、ByteDanceという巨大なプラットフォームで実際に大きな成果を上げ、すでにプロダクション環境に展開されている点です。

2. **検索フェーズにおける画一的なユーザー表現からの脱却**: 
  RankingフェーズではTarget Attentionなどを用いて、対象商品に応じた適切なユーザー表現を作成するのが一般的です。しかし、候補検索（Retrieval）のTwo-Towerモデルでは、計算コストの制約から画一的なユーザー表現（単一のベクトル）にならざるを得ず、表現力の限界が性能低下を招いていました。本論文がこの構造的な課題をどのように解決したのか、そのアプローチに関心を持ちました。

3. **長期系列データにおけるノイズの処理手法**: 
  Sequential Recommendationにおいて、行動履歴系列が長くなればなるほど、無関係でノイジーなインタラクションデータが含まれてしまうのが常です。本論文が超長期間のデータを扱う上で、どのようにしてノイズを排除し、有用なシグナルだけを抽出して活用しているのかを知りたいと考えました。

## 論文解説

本セクションでは、LongRetrieverがどのようにして「検索フェーズでの超長期間履歴活用」を実現したのか、その技術的詳細と実験結果について解説します。

### 概要 (Abstract)

ユーザーの興味を正確に捉えるためには「超長期間の行動シーケンス」の活用が不可欠ですが、既存のアプローチは主にランキング段階での活用に留まり、検索段階での研究は十分になされていませんでした。

そこで本論文では、検索段階において長期間シーケンスを活用するための実用的なフレームワークLongRetrieverを提案しています。具体的には、In-Context TrainingとMulti-Context Retrievalという手法を導入することで、ユーザー履歴と候補アイテム間の密な相互作用を実現し、かつ検索ベースにおける学習と推論の整合性を担保しました。  
大規模EコマースプラットフォームにおけるオンラインA/Bテストの結果、統計的に有意な性能向上が確認され、現在では数億ユーザーに影響を与える規模で実際にデプロイされています。

### 既存研究とこの論文の位置づけ (Introduction / Related Work)

これまで検索フェーズでの長期間履歴活用が困難であった背景と、本研究の立ち位置について整理します。

- 推薦システムの2段階構成:  
   産業界の推薦システムは通常、検索（Retrieval）とランキング（Ranking）の2段階で構成されます。検索フェーズでは、膨大なアイテムプールから候補を絞り込むために軽量なモデル（Two-Towerモデルなど）が採用され、ランキングフェーズでは精度を追求した計算コストの高いモデルが使用されます。  

- ランキングモデルにおける長期間履歴の活用:  
   ランキングモデルの分野では、DINやSIMといった手法の登場により、ターゲットアイテムに関連するユーザー行動を長期間の履歴から抽出する技術（Target Attention等）が進化し、予測精度の飛躍的な向上が実現しています。  

- 検索モデルの構造的制約:  
   一方で、検索モデル（Embedding-based Retrieval: EBR）は、高速な近傍探索（ANN）を実現するためにアイテムベクトルを事前にインデックス化する必要があります。このため、ユーザーエンコーダとアイテムエンコーダは独立して計算される必要があり、ランキングモデルのように候補アイテムに応じてユーザー表現を動的に変化させることが困難でした。結果として、検索フェーズでは直近の短い履歴しか扱えないという制約が存在していました。  

- 本論文のアプローチ:  
   LongRetrieverは、EBRのエンコーダ独立性という制約を遵守しつつ、アイテムのコンテキスト（カテゴリ等）をキーとして長期間履歴から関連部分を抽出するアプローチを採用することで、上述の課題を解決しています。

### 提案手法 (Methodology)

LongRetrieverの核心技術であるアーキテクチャの詳細と、In-Contextな学習・検索プロセスについて解説します。

#### 手法のコンセプト

数理的な詳細の前に、本手法の基本概念を説明します。

第一のポイントは、**ターゲットアイテムそのものではなくコンテキスト（カテゴリ）を利用する**点です。通常のEBRでは、推論時に候補アイテムが未知であるため、アイテム情報をユーザーベクトル生成に利用できません。そこでLongRetrieverでは、ユーザーの全行動履歴から、ユーザーが興味を持っているコンテキスト（例：食品）に関連する行動のみを抽出し、そのカテゴリに関心がある状態のユーザーベクトルを生成します。これにより、推論時の計算コストを抑えつつ、長期間の履歴を活用可能にします。

第二のポイントは、**学習時のデータリークの防止**です。単純に特定のカテゴリでフィルタリングした履歴を用いて学習を行うと、モデルは履歴のカテゴリとアイテムのカテゴリが一致しているかのみを判別基準としてしまい、アイテム自体の嗜好性を学習しなくなるリスクがあります。これを防ぐために、学習データの構成を工夫するIn-Context Trainingが導入されています。

第三のポイントは、**推論時の多様性の確保**です。ユーザーの興味は多岐にわたるため、単一のコンテキストのみで検索を行うのではなく、ユーザーの過去の行動に基づいて、興味を持っているであろう複数のコンテキストを選択し、並列して検索を行います（Multi-Context Retrieval）。さらに、単にスコアが高いコンテキストだけを選ぶと強い興味ばかりが推薦され、フィルターバブルに陥る可能性があります。これを防ぐため、スコア上位のコンテキスト群からランダムに選択する手法（Random in Top）を採用し、多様性を考慮した検索を実現しています。


#### 記号の凡例

本記事で使用する主な数式記号の定義は以下の通りです。

* $U$: 全ユーザーの集合
* $I$: 全アイテムの集合
* $u$: ユーザー ($u \in U$)
* $v$: ターゲットアイテム ($v \in I$)
* $B_u$: ユーザー $u$ の全行動履歴系列 ($=[b_1^u, b_2^u, \dots, b_T^u]$)
* $P_u$: ユーザー基本特徴量（プロファイルやコンテキスト情報など）
* $S_u$: ターゲットアイテムのコンテキストに基づいて $B_u$ からフィルタリングされた行動履歴サブシーケンス
* $e_u$: ユーザーベクトル（User Encoderの出力）
* $e_v$: アイテムベクトル（Item Encoderの出力）

#### 手法の詳細

具体的なモデル構造と数式を用いた解説は以下の通りです。

##### 1. モデルアーキテクチャと入力

LongRetrieverのUser Encoderには、学習の安定性を高めるために **Pre-Layer Normalization Transformer** が採用されています。ターゲットアイテムのコンテキスト（カテゴリ）$c$ に基づいてフィルタリングされたサブシーケンス $S_u$ を入力とし、以下の式で表現されます。

$$
e_u = \text{Transformer}([CLS, p_1^u, p_2^u, \dots, p_K^u, s_1^u, s_2^u, \dots, s_M^u])  
$$

長期履歴を対象商品のコンテキスト（カテゴリ）でフィルタリングすることで、対象商品に適したユーザーベクトルを生成します。また、対象商品とは無関係な商品のインタラクションを考慮する必要がなく、ノイズを除外することができます。

Transformerへの入力トークンは以下の3種類で構成され、これらが統合されて処理されます。

* \[CLS\] トークン:  
  シーケンス全体の情報を集約するための特殊トークンです。最終的なTransformer出力におけるこのトークンのベクトルが、ユーザー表現 $e_u$ として採用されます。  

* ユーザープロファイル特徴 ($P_u$):  
  ユーザーID、性別、年代などの属性情報から得られる $K$ 個のトークン ($p_1^u, \dots, p_K^u$) です。これにより、行動履歴だけでなくユーザー属性も考慮されます。  

* フィルタリングされた行動履歴 ($S_u$):  
  ユーザーの全行動履歴 $B_u$ から、ターゲットアイテムのコンテキスト（カテゴリ）に一致するものを抽出したサブシーケンス ($s_1^u, \dots, s_M^u$) です。ここで $M$ は最大長（例: 直近 $L$ 件）と設定されます。

これらのトークンに対し、学習可能な Positional Encodings（位置埋め込み）と Token Type Embeddings（トークン種別埋め込み）が加算され、Transformer層に入力されます。


![fig1a](https://storage.googleapis.com/zenn-user-upload/44b566888a94-20251209.png)
*Figure 1-a*


##### 2. In-Context Training (学習フェーズ)

EBRの一般的な学習では、ユーザー $u$ と正解アイテム $v$ の類似度 $e_u^T e_v$ を最大化するため、In-batch Contrastive Loss（バッチ内の他アイテムを負例とする損失関数）が用いられます。

$$
\mathcal{L}(e_u) = -\log \frac{\exp(e_u^T e_v / \tau)}{\exp(e_u^T e_v / \tau) + \sum_{v' \in \mathcal{N}} \exp(e_u^T e_{v'} / \tau)}
$$

ここで重要となるのが、負例集合 $\mathcal{N}$ の構成です。  
EBRでは、通常バッチ内の他アイテムを負例とします(In-Batch Negative Sampling)。ここで、本手法では、行動履歴の商品を、正解アイテムと同じコンテキスト（カテゴリ）にフィルタリングしているため、Transformerの出力ベクトル$e_u$は、正解アイテムと同じコンテキストを持ちます。そのため、通常のIn-Batch Negative Samplingでは、モデルはカテゴリの違いだけで容易に正解を判別できてしまいます（データリーク）。  
そこで **In-Context Training** では、負例 $v'$ を正解アイテムと同じコンテキスト（カテゴリ）を持つアイテムのみに限定して損失を計算します。これにより、モデルは同一カテゴリ内でのユーザーの好みの判別という、より詳細な粒度での学習を強制されることになります。

##### 3\. Multi-Context Retrieval (推論フェーズ)

推論時にはターゲットアイテムが未知であるため、どのコンテキスト（カテゴリ）で検索すべきかが自明ではありません。そこで以下の手順が採用されています。

* 1. Interest Selection (興味選択):  
   ユーザーの全履歴に基づき、現在興味を持っている可能性が高いカテゴリを選択します。各カテゴリ $c$ のスコアは、過去の行動に対する時間減衰を考慮して算出されます。
   ここで $\mathbb{I}(\cdot)$ は指示関数、$t_{b_i}$ は行動 $b_i$ の経過日数を表します。直近で接触したカテゴリほど高いスコアとなります。このスコア上位（Top M）から、多様性を確保するためにランダムに $N$ 個のカテゴリを選択します（Random in Top戦略）。  

$$
\text{Score}_{c} = \sum_{b_i \in B_u} \frac{\mathbb{I}(c_{b_i} = c)}{t_{b_i}}
$$  

* 2. Parallel Search (並列検索):  
   選択された各カテゴリについて、対応する履歴 $S_u$ を抽出してユーザーベクトル $e_u$ を生成し、そのカテゴリ専用のインデックスからアイテムを検索します。

![fig1b](https://storage.googleapis.com/zenn-user-upload/240554466de4-20251209.png)
*Figure 1 - b*


### 実験と結果 (Experiments / Results)

提案手法の有効性を検証するため、ByteDanceのショッピングモールにおける大規模な実験が行われました。比較対象としては、業界標準の一つであるマルチインタレストモデル「MIND」が採用されています。

#### 実験設定と評価指標の解説

実験には、9億ユーザー、1.5億アイテム、100億サンプルという極めて大規模なデータセットが使用され、ユーザーの行動履歴長は平均2万件を超えています。手法としてLongRetriever（Random 5 in Top 20戦略）を用い、MINDとの比較を行いました。

評価に使用された主な指標は以下の通りです。

* **ビジネス指標 (Business Metrics):**  
  * **PV (Page Views):** 商品詳細ページの閲覧数。  
  * **UV CTR (Unique Visitor Click-Through Rate):** ユニークユーザーあたりのクリック率。ユーザーの興味関心度合いを示します。  
  * **UV CVR (Unique Visitor Conversion Rate):** ユニークユーザーあたりのコンバージョン（購入）率。購買行動への直接的な寄与度を測ります。  
  * **Orders Per User:** ユーザー一人当たりの平均注文数。売上へのインパクトを示す重要指標です。  
* **検索品質指標 (Retrieval Metrics):**  
  * AER (All Exposure Ratio):  
    モデルが検索した全アイテムに対する選好度合いを測る指標です。この値が低いほど、無駄に広範囲（人気アイテムなど）を探索せず、特定のコンテキストに絞って効率的に候補を抽出できていることを示唆します。  
  * UER (Unique Exposure Ratio):  
    対象モデルのみが独自に検索できたアイテムの割合です。この値が高いほど、既存システムに対して新しい（ユニークな）アイテムを供給できていることを示し、推薦リスト全体の多様性に貢献します。

#### 実験結果と考察

* ビジネス指標の大幅な改善:  
  Table 1の結果によると、MINDと比較して UV CVR: +1.33%, Orders Per User: +1.70% という改善が確認されました。数十億ユーザー規模のサービスにおいて、この改善幅は極めて大きなビジネスインパクトを持ちます。  

![table1](https://storage.googleapis.com/zenn-user-upload/aa2dcb323aee-20251209.png)
*Table 1*


* **検索品質の変化 (Table 2):**  
  * **AERの低下 (31.82% → 18.72%):** MINDより大幅に低い値となりました。これは、MINDが全アイテムプールから広く探索するのに対し、LongRetrieverは特定のコンテキストに絞って探索するため、探索範囲が効率化されていることを意味します。  
  * UERの向上 (4.58% → 9.29%): **+4.71%** と約2倍に向上しました。これは、LongRetrieverが既存の手法では埋もれていたニッチだが特定のユーザーには刺さるアイテムを独自に発見し、ユーザーに届けていることを強く示唆しています。  

![table2](https://storage.googleapis.com/zenn-user-upload/0f04ac186048-20251209.png)
*Table 2*

* Ablation Study（構成要素の検証）:  
  提案手法の各要素の有効性についても詳細な分析が行われています。  
  1. 長期間シーケンスの重要性 (Table 4):  
     長期間シーケンス（Lifelong behavior）を除外すると、CTR×CVRが 7.92% → 5.33% へと激減しました。In-Context Trainingは「同一カテゴリ内のアイテムを見分ける」という難易度の高いタスクを課すため、学習には長期間の豊富な情報が不可欠であることを示しています。  
  2. In-Contextメカニズムの重要性 (Table 5):  
     In-Context Training/Retrievalを除外すると、見かけ上の多様性（AER/UER）は増加するものの、精度指標（CTR×CVR）は 5.61% に低下しました。これは、コンテキストを考慮しない場合、データリーク（カテゴリの一致のみでの正解判別）が発生し、実質的な学習が不十分になるためです。  
  3. 興味選択戦略 (Table 3):  
     推論時に興味カテゴリを選択する際、スコア上位5つ (Top 5)を固定で選ぶよりも、上位20個からランダムに5つ (Random 5 in Top 20)選ぶ方が、UER（独自性）が高く、エコシステムの健全性に寄与することが確認されました。

![table3](https://storage.googleapis.com/zenn-user-upload/434744a604f4-20251209.png)
*Table 3*

![table4](https://storage.googleapis.com/zenn-user-upload/79b5e7102147-20251209.png)
*Table 4*

![table5](https://storage.googleapis.com/zenn-user-upload/66b2a3307ba7-20251209.png)
*Table 5*

### 結論と限界や今後の展望(Discussion / Conclusion)

LongRetrieverは、検索段階においてユーザーと候補アイテムの相互作用を、In-Context TrainingとMulti-Context Retrievalによって実現しました。これにより、従来はランキング段階でのみ活用されていた長期間履歴の効果を、検索段階にも拡張することに成功しました。

今後の展望としては、カテゴリ割り当てや興味の抽出にLLM（大規模言語モデル）を活用し、より洗練されたコンテキスト生成を行う可能性が示唆されています。

## 記事著者の考察と実務への応用

ここからは、本論文を読んだ著者自身の考察です。

### 1. フィルターバブルと短期指標のバランス

論文中の実験結果（Table 3）を見ると、以下のトレードオフがあることが分かります

* 純粋な精度: Top 5の方が、提案手法のRandom 5 in Top 20よりもCTR×CVRが高い（8.29% vs 7.92%）。  
* 多様性と健全性: 一方で、Top 5はAERが高く（30.43%）、UERが低い（7.23%）。これは他のモデルでも推薦されやすい人気商品ばかりを推薦し、多様性が低くなり、フィルターバブルを助長している状態です。

実務においてこのトレードオフは非常に悩ましい問題です。「短期的な売上（CVR）を最大化するならTop 5」ですが、「プラットフォームの多様性と健全性（UER）を保つならRandom in Top」だからです。どちらを重視するかは、アルゴリズムだけの問題ではなく、LTVと多様性の関係を調査した上で、経営層と合意形成すべき戦略的な意思決定になるでしょう。

### 2. 興味の深掘りと探索の限界

この手法は、ユーザーの過去の行動履歴にあるカテゴリをフックにして検索を行います。

* 得意なこと: ユーザーが既に興味を示しているカテゴリの深掘り（Exploitation）。  
* 苦手なこと: まだ認知していないが、実は刺さるかもしれないカテゴリの発見（Exploration）。

この苦手なことは、単にモデルの精度が低いという話ではありません。ユーザーが未認知であるカテゴリは、当然ながら過去の行動系列（履歴）には存在しません。LongRetrieverは過去の行動をキーにしてContextを検索する仕組みである以上、履歴にないカテゴリはContextになり得ず、構造的に未知のカテゴリの探索が困難であるという点を理解しておく必要があります。

したがって、実務で運用する場合はこのモデル一本に頼るのではなく、別途人気ランキングや協調フィルタリングベースの手法、あるいはバンディットアルゴリズムなどを併用して、未知のカテゴリへのセレンディピティを補完する設計が必須になります。

### 3. 実務への応用可能性

結論として、実務への応用可能性は非常に高いと感じます。

* 既存資産の活用: 既に検索インデックス（FaissやHNSW）を持っている環境であれば、アイテムをカテゴリごとに分割インデックス化（あるいはフィルタ付き検索）するだけで対応可能です。  

* 現実的なレイテンシ: ユーザーの全履歴をリアルタイムで処理するのは重すぎますが、カテゴリに関連するサブシーケンスだけをTransformerに入れるのであれば、推論レイテンシも許容範囲内に収めやすい設計だからです。

## まとめ

LongRetrieverは、超長期間履歴と、対象商品ごとの適切なユーザーベクトルを作成するRetrieval手法です。カテゴリで履歴を絞る（Search-based）＋そのカテゴリ内での差別化を学習する（In-Context）という組み合わせにより、計算コストと精度のトレードオフを解消しています。

一方で、既知のカテゴリしか考慮しないという制限があるため、未知のカテゴリへのセレンディピティを補完するためには、別途人気ランキングや協調フィルタリングベースの手法、あるいはバンディットアルゴリズムなどを併用する必要があります。

手法としては非常にシンプルで、実装もしやすいため、検証する価値は非常に高いと考えています。



## 参考文献・次に読むべき論文

* 本論文:  
  * [Long Retriever: Towards Ultra-Long Sequence based Candidate Retrieval for Recommendation (arXiv 2025\)](https://arxiv.org/abs/2508.15486)  
* 関連する重要論文:  
  * MIND: [Multi-Interest Network with Dynamic Routing (CIKM 2019)](https://arxiv.org/abs/1904.08030) - 比較対象となったマルチインタレストモデル。
  * SIM: [Search-based User Interest Modeling (CIKM 2020)](https://arxiv.org/abs/2006.05639) - Rankingフェーズでの検索ベースのアプローチを確立した研究。LongRetrieverの着想元の一つ。
  * DIN: [Deep Interest Network (KDD 2018)](https://arxiv.org/abs/1706.06978) - Attention機構によるユーザー興味モデリングの基礎。
